# TypeScript実装計画 - Ruby実装をベースにした段階的アプローチ

Ruby実装を参考にしながら、TypeScriptでMCPクライアント・サーバーを段階的に実装するための計画を以下に示します。各段階はPR単位で区切ることで、レビューがしやすく、機能テストも段階的に行えるようにします。

## フェーズ1: 基本構造とインターフェース (PR #1)

**目標**: TypeScriptプロジェクトの基本構造と型定義を整備

### 実装内容:

1. **基本的な型定義**
   - `src/types/mcp.ts`: MCPプロトコルの型定義
   - `src/types/tools.ts`: ツールの型定義
   - `src/types/llm.ts`: LLMプロバイダーの型定義

2. **インターフェース定義**
   - `src/interfaces/connection.ts`: 通信インターフェース
   - `src/interfaces/logger.ts`: ロガーインターフェース
   - `src/interfaces/llm-provider.ts`: LLMプロバイダーインターフェース

3. **基本的なクラス構造のスケルトン**
   - `src/mcp/client.ts`: MCPクライアントの骨格
   - `src/mcp/server.ts`: MCPサーバーの骨格
   - `src/mcp/host.ts`: MCPホストの骨格

### テスト内容:
- インターフェースの型定義テスト
- 基本クラス構造の初期化テスト
- TypeScript設定の有効性確認（tscコンパイル確認）

### PR内容:
```
PR #1: TypeScript基本構造と型定義の実装

- TypeScriptプロジェクトの初期化と設定
- MCPプロトコル関連の型定義
- 基本インターフェースの設計
- クラス構造のスケルトン実装
```

## フェーズ2: コア機能の実装 (PR #2)

**目標**: MCPの基本的なクライアント/サーバー機能を実装

### 実装内容:

1. **コネクション実装**
   - `src/mcp/stdio-connection.ts`: 標準入出力を使った通信

2. **ロガー実装**
   - `src/utils/logger.ts`: Winstonを使用したロガー

3. **クライアント実装**
   - `src/mcp/client.ts`: 実際のメソッド実装
   - initialize, ping, listTools, callTool等の実装

4. **サーバー実装**
   - `src/mcp/server.ts`: メッセージハンドリング
   - ツール登録機能
   - 実行フロー

5. **テスト**
   - 単体テストの作成

### テスト内容:
- 通信機能のユニットテスト（モックストリーム使用）
- JSONRPCメッセージのシリアライズ/デシリアライズテスト
- クライアントメソッドのユニットテスト
- サーバーのリクエスト処理テスト
- エラーハンドリングテスト

### PR内容:
```
PR #2: MCPコア機能実装

- stdio通信の実装
- JSONRPCメッセージング
- MCPクライアント機能の実装
- MCPサーバー機能の実装
- ロギング機能
- 単体テスト
```

## フェーズ3: ツール実装 (PR #3)

**目標**: Ruby実装と同等のツールを実装

### 実装内容:

1. **ツール基本クラス**
   - `src/tools/base-tool.ts`: 抽象基底クラス

2. **各種ツール実装**
   - `src/tools/dice.ts`: サイコロツール
   - `src/tools/current-time.ts`: 現在時刻ツール
   - `src/tools/weather.ts`: 天気ツール（ダミー）

3. **ツール登録メカニズム**
   - `src/tools/index.ts`: ツール集約と登録

4. **マルチツールサーバー**
   - `src/servers/multi-tools-server.ts`: 複数ツールを持つサーバー

### テスト内容:
- 各ツールの入力検証テスト
- 各ツールの出力検証テスト
- ランダム値生成（サイコロ）の分布テスト
- 時刻フォーマットの正確性テスト
- ツール登録メカニズムの動作確認
- マルチツールサーバーでの複数ツール登録・呼び出しテスト

### PR内容:
```
PR #3: ツール実装

- ツール基底クラスの実装
- サイコロツールの実装
- 現在時刻ツールの実装
- 天気ツールの実装（ダミー）
- マルチツールサーバーの実装
- ツールのユニットテスト
```

## フェーズ4: LLMプロバイダー実装 (PR #4)

**目標**: OpenAIとAnthropicのLLMプロバイダーを実装

### 実装内容:

1. **LLMプロバイダー基底クラス**
   - `src/llm-provider/base-provider.ts`: 抽象基底クラス

2. **OpenAIプロバイダー**
   - `src/llm-provider/openai.ts`: OpenAI API連携

3. **Anthropicプロバイダー**
   - `src/llm-provider/anthropic.ts`: Anthropic API連携

4. **ファクトリークラス**
   - `src/llm-provider/factory.ts`: プロバイダー生成

5. **環境変数統合**
   - `src/config.ts`: 設定読み込み

### テスト内容:
- APIリクエスト構築テスト
- レスポンスパースのユニットテスト
- モックレスポンスを使用したプロバイダー動作テスト
- エラーハンドリングテスト（レート制限、無効なAPIキーなど）
- 環境変数読み込みテスト
- ファクトリーパターンの正常動作テスト
- ツール呼び出し時のLLM連携テスト

### PR内容:
```
PR #4: LLMプロバイダー実装

- LLMプロバイダー基底クラスの実装
- OpenAI APIクライアントの実装
- Anthropic APIクライアントの実装
- プロバイダーファクトリーの実装
- 環境変数からの設定読み込み
- ツール呼び出し連携の実装
```

## フェーズ5: ホスト機能とCLI実装 (PR #5)

**目標**: ユーザーが利用するホスト機能とCLIを実装

### 実装内容:

1. **ホスト機能実装**
   - `src/mcp/host.ts`: MCPホスト完全実装
   - LLM連携
   - ツール選択&実行
   - 応答処理

2. **CLIアプリケーション**
   - `src/main.ts`: エントリーポイント
   - コマンドライン引数処理
   - ヘルプ表示

3. **ユーティリティ**
   - `src/utils/cli.ts`: CLI関連ユーティリティ

4. **統合テスト**
   - End-to-Endテスト

### テスト内容:
- コマンドライン引数解析のユニットテスト
- ヘルプメッセージ表示テスト
- ホスト-サーバー間通信の統合テスト
- LLM呼び出しの統合テスト（モック使用）
- End-to-Endテスト（実際のサーバー起動とツール呼び出し）
- エラー状態のハンドリングテスト（サーバー停止、接続エラーなど）
- タイムアウト処理のテスト

### PR内容:
```
PR #5: ホスト機能とCLI実装

- ホスト機能の完全実装
- コマンドラインインターフェイス
- 対話型インターフェイス
- LLM-ツール連携フロー
- オプション処理
- 統合テスト
```

## フェーズ6への準備 (中間修正)

**目標**: フェーズ1-5の実装の問題点を修正し、テストが正常に動作する状態にする

### 修正内容:

1. **モジュール互換性の修正**
   - `src/utils/schema-validator.ts`: CommonJSからESMへの移行
   - Ajvの使用方法をESM互換に変更

2. **テスト環境の改善**
   - Jest設定の最適化
   - `jest.mock`の正しい使用方法の適用
   - モックの実装方法の見直し

3. **失敗しているテストの修正**
   - ホストテストの修正
   - ツール関連のテスト修正
   - LLMプロバイダーテストの修正

4. **コードの整理と整合性確保**
   - ESM/CommonJS混在の解消
   - 型定義の整合性確認
   - エラーハンドリングの整理

### 成果物:
- すべてのテストが正常に実行できる状態
- 無駄なデバッグログの削除
- ビルドエラーの解消
- 依存関係の整理

## フェーズ6: 最適化と拡張機能 (PR #6)

**目標**: TypeScriptの特性を活かした拡張と最適化

### 実装内容:

1. **パフォーマンス改善**
   - 非同期処理の最適化
   - エラーハンドリングの強化

2. **型安全性の強化**
   - 厳密な型チェック
   - ジェネリクスの活用

3. **拡張機能**
   - ツール登録のプラグイン化
   - ロガーの拡張
   - ストリーミング対応検討

4. **ドキュメント整備**
   - JSDoc完備
   - 使用例
   - API参照

### テスト内容:
- パフォーマンステスト（リクエスト処理時間測定）
- メモリ使用量テスト
- 負荷テスト（多数のツール同時実行）
- エラー復旧テスト
- プラグイン機能のテスト
- ストリーミングモードの動作テスト（実装した場合）
- リファクタリング後の全既存テストの再実行

### PR内容:
```
PR #6: 最適化と拡張機能

- 非同期処理の最適化
- 型安全性の強化
- エラーハンドリングの改善
- 拡張機能の実装
- ドキュメント整備
- パフォーマンステスト
```

## フェーズ6.5: 自然言語インターフェースの実装 (PR #6.5)

**目標**: コマンドラインで自然言語入力を受け付け、LLMからのレスポンスを返す機能を実装

### 実装内容:

1. **対話型CLIの強化**
   - `src/interfaces/cli-interface.ts`: CLI対話インターフェースの定義
   - `src/cli/natural-language-cli.ts`: 自然言語入力処理クラス

2. **LLMとの対話フロー実装**
   - `src/mcp/chat-session.ts`: チャットセッション管理
   - 履歴管理機能
   - ストリーミングレスポンス対応

3. **main.tsの拡張**
   - `--chat`モード追加
   - 自然言語入力処理フロー統合

4. **UI/UX改善**
   - プログレスインジケーター
   - 読みやすいフォーマット
   - エラーメッセージの改善

### テスト内容:
- 対話モードの正常動作テスト
- ユーザー入力のモック作成と応答テスト
- LLMプロバイダーとの連携テスト
- 異常入力時の対応テスト
- チャットセッションの履歴管理テスト
- 長時間対話の安定性テスト

### PR内容:
```
PR #6.5: 自然言語インターフェースの実装

- 対話型自然言語CLIの実装
- チャットセッション管理機能
- LLMプロバイダーとの統合
- コマンドライン引数拡張（--chatモード）
- ユーザー体験の向上
- テスト拡充
```

## フェーズ6.75: 自然言語インターフェースのツール連携強化 (PR #6.75)

**目標**: Ruby実装を参考に、自然言語対話モードとMCPサーバーのツールを連携させる

### 実装内容:

1. **Ruby実装の連携モデルを導入**
   - `NaturalLanguageCLI` と `MCPHost` の連携強化
   - ホスト経由でのツールアクセスパターンの実装
   - ツール実行結果のLLMへのフィードバック機能

2. **ツール検出と実行フロー**
   - LLM応答からツール呼び出しを検出する機能
   - 検出されたツールのMCPサーバーでの実行
   - ツール実行結果をLLMに戻して最終応答を生成

3. **段階的実装アプローチ**
   - フェーズ1: 基本的な対話モードの安定化
   - フェーズ2: ツール連携機能の追加
   - インターフェースの調整（必要に応じて）

4. **UI/UX改善**
   - ツール実行中のフィードバック
   - ツールの利用状況の視覚化
   - エラーハンドリングの強化

### テスト内容:
- ツール検出と実行のユニットテスト
- LLM応答からのツール呼び出し抽出テスト
- MCPサーバーとの連携テスト
- エラー状態のハンドリングテスト
- 完全な対話フローのE2Eテスト

### 成果物:
- Ruby実装と同等のツール連携機能を持つ自然言語対話モード
- よりシンプルで理解しやすいコード構造
- TypeScriptの静的型付けを活かした堅牢な実装

### PR内容:
```
PR #6.75: 自然言語インターフェースのツール連携強化

- Ruby実装を参考にしたツール連携モデルの導入
- LLM応答からのツール使用検出機能
- ツール実行とLLMへのフィードバック機能
- 段階的な実装アプローチ
- UI/UXの改善
- エラーハンドリングの強化
- テストの拡充
```

## フェーズ7: 完成と展望 (PR #7)

**目標**: 実装の最終調整とRuby実装との相互運用性検証

### 実装内容:

1. **最終調整**
   - エッジケース対応
   - バグ修正

2. **相互運用性**
   - Ruby実装とTypeScript実装の比較
   - 運用ドキュメント

3. **将来展望**
   - 今後の開発方向性
   - 追加機能の提案

### テスト内容:
- Ruby実装との互換性テスト
- 完全なEnd-to-Endテスト
- 異なる環境でのクロステスト（Windows/Mac/Linux）
- エッジケースのテスト（巨大なメッセージ、異常な入力値など）
- ドキュメントの正確性検証
- インストールテスト（新規環境での動作確認）

### PR内容:
```
PR #7: 完成と展望

- 最終調整とバグ修正
- Ruby実装との相互運用性検証
- パッケージング
- デプロイメント
- 今後の開発計画
```

## 実装スケジュール

| フェーズ | 予想期間 | 優先度 | 
|----------|----------|--------|
| 1: 基本構造 | 1-2日 | 高 |
| 2: コア機能 | 2-3日 | 高 |
| 3: ツール実装 | 1-2日 | 高 |
| 4: LLMプロバイダー | 2-3日 | 高 |
| 5: ホスト&CLI | 1-2日 | 中 |
| 6への準備 | 1-2日 | 高 |
| 6: 最適化 | 2-3日 | 中 |
| 6.5: 自然言語インターフェース | 1-2日 | 中 |
| 6.75: 自然言語インターフェースのツール連携強化 | 1-2日 | 中 |
| 7: 完成 | 1日 | 低 |

## 開発方針

1. **段階的開発**: 各フェーズで動作確認できる状態を保つ
2. **テスト駆動**: 各機能に対する単体テストを先に書く
3. **型安全性**: TypeScriptの型システムを最大限活用
4. **非同期処理**: 適切な非同期パターンを採用
5. **拡張性**: プラグイン的な構造で拡張しやすいアーキテクチャに

## ブランチ戦略

- 基本ブランチ: `refactor/monorepo`
- 機能開発ブランチ: `feature/ts-フェーズ名`
  例：`feature/ts-core`、`feature/ts-tools`など
- 各PRマージ後、次のフェーズを開始

## Ruby実装との比較

TypeScript実装では、以下の点でRuby実装から改善・拡張を行います：

1. **型安全性**: TypeScriptの静的型付けを活用し、実行前にエラーを検出
2. **非同期処理**: 適切な非同期パターンを使った効率的な実装
3. **モジュール性**: より明確な責務分離と拡張性の高い設計
4. **テスト可能性**: モックやスタブを活用した単体テストの強化
5. **ドキュメント**: JSDocによる詳細なAPIドキュメントの自動生成

## テストフレームワークと戦略

### テストフレームワーク
- **Jest**: 主要なテストフレームワークとして使用
- **ts-jest**: TypeScriptサポート
- **supertest**: HTTPテスト用（必要な場合）
- **nock**: 外部APIモック用

### テスト階層
1. **ユニットテスト**: クラスとメソッドの個別テスト
   - `__tests__/unit/`ディレクトリに配置
   - ファイル名パターン: `*.spec.ts`
   - モックを活用してクラス間の依存を切り離す

2. **統合テスト**: モジュール間連携のテスト
   - `__tests__/integration/`ディレクトリに配置
   - サーバー-クライアント間通信
   - ツール実行フロー全体

3. **End-to-Endテスト**: システム全体のテスト
   - `__tests__/e2e/`ディレクトリに配置
   - 実際のコマンド実行と応答確認

### テストカバレッジ
- 目標カバレッジ: 80%以上
- Istanbulを使用したカバレッジレポート
- PRごとにカバレッジチェック

### CI統合
- GitHub Actionsでの自動テスト実行
- PRごとのテスト実行
- マルチOSテスト（Windows/Mac/Linux）

### テストデータ
- `__tests__/fixtures/`にテストデータ格納
- モックレスポンスのJSONファイル
- テスト用設定ファイル

## 注意点

1. **非同期処理**: Nodeの非同期I/Oモデルに合わせた設計が必要
2. **プロセス管理**: `child_process`を使用する際の適切なエラーハンドリングとリソース管理
3. **依存関係**: 外部パッケージの選定と依存関係の管理
4. **プラットフォーム互換性**: Windows/Mac/Linuxでの動作検証
5. **エラーハンドリング**: TypeScriptならではの例外処理とエラー型の活用 